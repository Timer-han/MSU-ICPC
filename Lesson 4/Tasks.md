<p>MSU Autumn 2022 Contest 4 Easy</p>
<p># A. Без героев</p>
<p>ограничение по времени на тест: 1 s.</p>
<p>ограничение по памяти на тест: 256 MB</p>
<p>вводstandard input</p>
<p>выводstandard output</p>
<p>Даны два массива, a и b. Нужно добиться следующего: mini(ai)≥maxj(bj). Для этого можно сколько угодно раз выполнять следующую операцию с массивами a и b: уменьшить или увеличить любой элемент любого массива на 1. Операцию можно применять несколько раз к одним и тем же элементам.</p>
<p>Входные данные</p>
<p>Два натуральных числа через пробел — n, m (1≤n,m≤105). Во второй строке записано n целых чисел через пробел — элементы массива a (1≤ai≤109). В третьей строке записано m целых чисел через пробел — элементы массива b (1≤bi≤109).</p>
<p>Выходные данные</p>
<p>Выведите единственное целое число — минимальное количество операций, необходимых для достижения указанного выше соотношения.</p>
<p>Примеры</p>
<p>входные данные </p>
<p>2 2</p>
<p>2 3</p>
<p>3 5</p>
<p>выходные данные </p>
<p>3</p>
<p>входные данные </p>
<p>3 2</p>
<p>1 2 3</p>
<p>3 4</p>
<p>выходные данные </p>
<p>4</p>
<p>входные данные </p>
<p>3 2</p>
<p>4 5 6</p>
<p>1 2</p>
<p>выходные данные </p>
<p>0</p>
<p>Примечание</p>
<p>В первом тестовом примере можно увеличить a1 на 1 и уменьшить b2 на 1, затем снова уменьшить b2 на 1. Теперь массив a выглядит так [3; 3], массив b выглядит так [3; 3]. Наименьший элемент a не меньше наибольшего элемента b. За меньшее количество операций — не получится.</p>
<p>В примере 3 не надо выполнять никаких операций, условие удовлетворено изначально.</p>
<p># B. Эстонский бензин</p>
<p>ограничение по времени на тест: 1 секунда</p>
<p>ограничение по памяти на тест: 256 мегабайт</p>
<p>ввод: стандартный ввод</p>
<p>вывод: стандартный вывод</p>
<p>Леша очень любит эстонский бензин, поэтому, поступив на КТ, он решил в свободное время заняться производством вариаций этой легендарной жидкости.</p>
<p>Всего у Леши есть n ингредиентов, i-й из которых имеет мощность ai. А еще у него есть m замечательных идей того, какие ингредиенты стоит использовать, чтобы результат обладал высоким качеством.</p>
<p>Идея номер i описывается двумя числами li и ri — ограничениями на мощность ингредиентов. Реализуя эту идею, Леша будет использовать ингредиенты с мощностями x и y (это может быть один и тот же ингредиент) такие, что li≤x≤y≤ri. Качество полученного бензина при этом оценивается как y−x.</p>
<p>Для каждой Лешиной идеи определите, какого максимального качества бензина он может достичь с заданными ограничениями. Если для данных li и ri не существует ни одного подходящего ингредиента, считайте качество результата равным нулю.</p>
<p>Входные данные</p>
<p>В первой строке дано целое число n — количество ингредиентов (1≤n≤105).</p>
<p>Во второй строке через пробел перечислены n целых чисел ai — мощности ингредиентов (−109≤ai≤109).</p>
<p>В третьей строке задается число m — количество идей (1≤m≤105), после чего в i-й из m следующих строк через пробел даны два числа li и ri — ограничения на мощности используемых в рамках этой идеи ингредиентов (−109≤li,ri≤109).</p>
<p>Выходные данные</p>
<p>Для каждой Лешиной идеи (li,ri) выведите в отдельной строке максимальную разность между мощностями ингредиентов, лежащими в диапазоне от li до ri включительно, или «0» (без кавычек), если подходящих ингредиентов нет.</p>
<p>Примеры</p>
<p>входные данные </p>
<p>5</p>
<p>5 1 13 4 7</p>
<p>4</p>
<p>5 8</p>
<p>3 10</p>
<p>-1 150</p>
<p>1 10</p>
<p>выходные данные </p>
<p>2</p>
<p>3</p>
<p>12</p>
<p>6</p>
<p>входные данные </p>
<p>3</p>
<p>1 2 3</p>
<p>3</p>
<p>1 2</p>
<p>2 3</p>
<p>1 3</p>
<p>выходные данные </p>
<p>1</p>
<p>1</p>
<p>2</p>
<p>входные данные </p>
<p>10</p>
<p>100 -34 -56 22 78 -79 41 9 35 89</p>
<p>5</p>
<p>4 77</p>
<p>-100 100</p>
<p>-51 10</p>
<p>33 67</p>
<p>-98 -79</p>
<p>выходные данные </p>
<p>32</p>
<p>179</p>
<p>43</p>
<p>6</p>
<p>0</p>
<p># C. След</p>
<p>ограничение по времени на тест: 2 s.</p>
<p>ограничение по памяти на тест: 256 MB</p>
<p>вводstandard input</p>
<p>выводstandard output</p>
<p>Зададим следующую функцию f(x):</p>
<p>f(x)={x2x−1если x четноеиначе </p>
<p>Заметим, что при применении многократно к любому v функции f, (для числа v вычисляем f(v), потом применяем функцию f к числу f(v) и т.д.), в конечном счёте мы получим 1. Запомним промежуточные значения на пути от v до 1 и назовем их следом: trace(v). Например, trace(1)=[1], trace(15)=[15,14,7,6,3,2,1], trace(32)=[32,16,8,4,2,1].</p>
<p>Выпишем все trace(x) для всех x от 1 до n. Вам необходимо определить максимальное число m такое, что m встречается хотя бы в k различных trace(x).</p>
<p>Иначе говоря, нужно найти такое максимальное y, что |{x | 1≤x≤n,y∈trace(x)}|≥k.</p>
<p>Входные данные</p>
<p>В первой строке следуют два целых числа n и k (1≤k≤n≤1018).</p>
<p>Выходные данные</p>
<p>Выведите максимальное число m такое, что m встречается хотя бы в k различных trace(x).</p>
<p>Примеры</p>
<p>входные данные </p>
<p>11 3</p>
<p>выходные данные </p>
<p>5</p>
<p>входные данные </p>
<p>11 6</p>
<p>выходные данные </p>
<p>4</p>
<p>входные данные </p>
<p>20 20</p>
<p>выходные данные </p>
<p>1</p>
<p>входные данные </p>
<p>14 5</p>
<p>выходные данные </p>
<p>6</p>
<p>входные данные </p>
<p>1000000 100</p>
<p>выходные данные </p>
<p>31248</p>
<p>Примечание</p>
<p>В первом примере ответ равен 5, так как 5 встретится в trace(5), в trace(10) и в trace(11).</p>
<p>Во втором примере ответ равен 4, так как 4 встретится в trace(4), в trace(5), в trace(8), в trace(9), в trace(10) и в trace(11).</p>
<p>В третьем примере n=k, поэтому ответ равен 1, так как 1 это единственное число, содержащееся в путях всех чисел от 1 до 20.</p>
<p># D. Поиск ближнего</p>
<p>ограничение по времени на тест: 1 секунда</p>
<p>ограничение по памяти на тест: 256 мегабайт</p>
<p>ввод: стандартный ввод</p>
<p>вывод: стандартный вывод</p>
<p>Даны два массива a размера n и b размера k. Для каждого bi найти такое aj что |aj−bi|→min. Если таких aj несколько, вывести минимальное.</p>
<p>Входные данные</p>
<p>В первой строке два числа N и K (1≤N,K≤105). Во второй строке N чисел массива a, отсортированного по неубыванию, а в третьей строке – K чисел массива b.</p>
<p>|ai|≤2⋅109, |bi|≤2⋅109</p>
<p>Выходные данные</p>
<p>Выведите K строк по одному числу – ответ для очередного bi.</p>
<p>Пример</p>
<p>входные данные </p>
<p>5 5</p>
<p>1 3 5 7 9</p>
<p>2 4 8 1 6</p>
<p>выходные данные </p>
<p>1</p>
<p>3</p>
<p>7</p>
<p>1</p>
<p>5</p>
<p># E. Найм юнитов</p>
<p>ограничение по времени на тест: 3 s.</p>
<p>ограничение по памяти на тест: 256 MB</p>
<p>вводstandard input</p>
<p>выводstandard output</p>
<p>Русский кот Шлёпа играет в компьютерную игру "Герои меча и магии". В начале каждого дня Шлёпа зарабатывает ровно один золотой.</p>
<p>В игре есть n типов существ. Каждое существо каждого типа стоит 2 монеты обычно — и 1 монету, когда этот тип на распродаже. Шлёпа хочет купить ровно ki существ i-го типа (он покупает существ в конце дня).</p>
<p>Шлёпа может купить любое (возможно, нулевое) количество существ любых типов в течение любого дня (конечно, если ему хватает золота, чтобы это сделать). Если тип существ, который он хочет купить, находится на распродаже, он может купить существо этого типа за 1 золотой, иначе — за 2 золотых.</p>
<p>У Шлёпы есть список, в какие из m дней случаются какие-либо распродажи. j-я запись в списке (dj,tj) означает, что существа tj-го типа находятся на распродаже в течение dj-го дня.</p>
<p>Шлёпа хочет купить всех существ как можно раньше. Ваша задача — найти минимальный номер дня, когда он сможет купить всех желаемых существ.</p>
<p>Входные данные</p>
<p>Первая строка входных данных содержит два целых числа n и m (1≤n,m≤2⋅105) — количество типов существ и количество записей в списке.</p>
<p>Вторая строка входных данных содержит n целых чисел k1,k2,…,kn (0≤ki≤2⋅105), где ki означает количество существ i-го типа, которое Шлёпа хочет купить. Гарантируется, что сумма всех ki не меньше 1 и не больше 2⋅105.</p>
<p>Следующие m строк содержат записи о распродажах. j-я из этих строк содержит j-ю запись. Она задана в виде пары целых чисел (dj,tj) (1≤dj≤2⋅105,1≤tj≤n) и означает, что сушества tj-го типа находятся на распродаже в течение dj-го дня.</p>
<p>Выходные данные</p>
<p>Выведите одно целое число — минимальный номер дня, когда Шлёпа сможет купить всех существ, которых он хочет.</p>
<p>Примеры</p>
<p>входные данные </p>
<p>5 6</p>
<p>1 2 0 2 0</p>
<p>2 4</p>
<p>3 3</p>
<p>1 5</p>
<p>1 2</p>
<p>1 5</p>
<p>2 3</p>
<p>выходные данные </p>
<p>8</p>
<p>входные данные </p>
<p>5 3</p>
<p>4 2 1 3 2</p>
<p>3 5</p>
<p>4 2</p>
<p>2 5</p>
<p>выходные данные </p>
<p>20</p>
<p># F. Расстояние</p>
<p>ограничение по времени на тест: 2 секунды</p>
<p>ограничение по памяти на тест: 512 мегабайт</p>
<p>ввод: стандартный ввод</p>
<p>вывод: стандартный вывод</p>
<p>Given an integer array a of length n and integer k.</p>
<p>Define function f(S, i), where S⊂{0,1,…,n−1}, and 0≤i<n, as f(S, i)=∑j∈S|ai−aj|.</p>
<p>For each i print f(Si, i)→min where i∉Si and |Si|=k.</p>
<p>Входные данные</p>
<p>The first line contains integers n and k (2≤n≤3⋅105, 1≤k<n).</p>
<p>The second line contains n integers ai (1≤ai≤109).</p>
<p>Выходные данные</p>
<p>Print n integers, i-th of them should be minimal possible value of f(Si, i).</p>
<p>Примеры</p>
<p>входные данные </p>
<p>4 2</p>
<p>1 2 3 4</p>
<p>выходные данные </p>
<p>3 2 2 3</p>
<p>входные данные </p>
<p>5 3</p>
<p>3 2 5 1 2</p>
<p>выходные данные </p>
<p>4 2 8 4 2</p>
<p>входные данные </p>
<p>6 2</p>
<p>3 2 1 101 102 103</p>
<p>выходные данные </p>
<p>3 2 3 3 2 3</p>
<p>Примечание</p>
<p>First example:</p>
<p>i=0: S0={1,2}; f({1,2}, 0)=|1−2|+|1−3|=3.</p>
<p>i=1: S1={0,2}; f({0,2}, 1)=|2−1|+|2−3|=2.</p>
<p>i=2: S2={1,3}; f({1,3}, 2)=|3−2|+|3−4|=2.</p>
<p>i=3: S3={1,2}; f({1,2}, 3)=|4−2|+|4−3|=3.</p>